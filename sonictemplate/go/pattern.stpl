\(.*\)\.try$
	if err := {{$1}}; err != nil {
		{{_cursor_}}
	}

\(\S\+\)\.for\.\(\S\+\)$
	for _, {{$1}} := range {{$2}} {
		{{_cursor_}}
	}

\(\S\+\)\.str$
	type {{$1}} struct {
		{{_cursor_}}
	}

\(".*"\)\.errn$
	errors.New({{$1}})
	{{_cursor_}}

\(".*"\)\.open
	file, err := os.Open({{$1}})
	if err != nil {
		return err
	}
	defer file.Close()
	{{_cursor_}}

errf
	if err != nil {
		log.Fatal(err)
	}
	{{_cursor_}}

return.err
	if err != nil {
		return err
	}
	{{_cursor_}}

\(".*"\)\.\(".*"\)\.db.open
	db, err := db.Open({{$1}}, {{$2}})
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()
	{{_cursor_}}

\(".*"\)\.db.query
	rows, err := db.Query({{$1}})
	if err != nil {
		log.Fatal(err)
	}
	defer rows.Close()
	{{_cursor_}}

json\.decode\.\(\S\+\)\.\(\S\+\)$
	if err := json.NewDecoder({{$1}}).Decode({{$2}}); err != nil {
		{{_cursor_}}
	}

json\.encode\.\(\S\+\)\.\(\S\+\)$
	if err := json.NewEncoder({{$1}}).Encode({{$2}}); err != nil {
		{{_cursor_}}
	}

\(\S\+\)\.logf
	log.Fatal({{$1}})

^main$
	package main
	
	func main() {
		{{_cursor_}}
	}

http\.server\.\(\S\+\)$
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Hello Gorilla"))
	})
	log.Fatal(http.ListenAndServe(":{{$1}}", nil))
	{{_cursor_}}

http\.file$
	http.Handle("/", http.FileServer(http.Dir(".")))
	{{_cursor_}}

http\.handle$
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		{{_cursor_}}
	}

\(\S\+\)\.map\.\(\S\+\)\.\(\S\+\)$
	{{$1}} := map[{{$2}}]{{$3}} {
		{{_cursor_}}
	}
	
