---
paths:
  - "**/*_spec.lua"
  - "**/*_test.go"
  - "**/*.rs"
  - "**/*.test.ts"
  - "**/*.spec.ts"
---

# テスト共通ルール

## 基本原則

### テストは仕様である
テストはシステムが何をするかを明確に伝えるべき。テストは実行可能なドキュメントである。

### テストはセーフティネットである
テストはリファクタリングで何も壊れていない確信を与える。失敗すべき時にのみ失敗すべき。

### 実装ではなく振る舞いをテストする
実装の詳細ではなく、外部から観測可能な振る舞いをテストする。

**リトマス試験**: テストが失敗した時、ユーザーにとって何が壊れたか説明できるか？できないなら、それは振る舞いのテストではない。

```
// Bad: 設定値のアサーション（トートロジー、仕様として無意味）
assert(config.enabled == true)
assert(capabilities.open_close == true)

// Good: 振る舞いのテスト
// 「ドキュメントが開かれた時、サーバーはXXを行う」をテスト
```

**リファクタリングでテストが壊れるなら、実装の詳細をテストしている。**

### テストの独立性
各テストは完全に独立していなければならない：
- 実行順序に依存しない
- 可変状態を共有しない
- 作成したリソースをクリーンアップする
- 競合を避けるため一意のテストデータを使用する

## セルフレビューチェックリスト

テスト実装後、各テストを以下のチェックリストで必ずセルフレビューする：

1. **振る舞いのテストか？** - このテストが失敗した時、ユーザーにとって何が壊れたか説明できるか？
   - ❌ 設定値のアサーション - 設定値であり振る舞いではない
   - ✅ ユーザーに見える出力のアサーション - ユーザーに見える振る舞い

2. **トートロジーではないか？** - このテストは意味のあることを検証しているか？
   - ❌ getterがsetした値を返すことのテスト
   - ✅ 入力Aが出力Bを生成することのテスト

3. **冗長なヘルパーはないか？** - 不要な抽象化はないか？
   - ❌ 1行で済むものをヘルパー関数に抽出
   - ✅ 直接呼び出しで明確に表現

4. **既存パターンを盲目的に踏襲していないか？** - 他からコピーして評価せずに使っていないか？
   - 各テストを個別にこれらのルールに照らして評価する

**いずれかのチェックに失敗したら、先に進む前にテストを修正する。**

## テスト命名規則

シナリオと期待される振る舞いを説明する記述的な名前を使用：

```
// パターン: function_name_scenario_expected_behavior
test_parse_version_with_invalid_input_returns_error
test_calculate_total_with_empty_cart_returns_zero

// エッジケースは具体的に
test_parse_version_with_leading_v_strips_prefix
```

## アサーションルール

### 文字列アサーションは完全一致を使用

`contains()`や部分一致ではなく、完全一致比較を使用：

```
// Good: 完全一致 - 意図しないメッセージ変更を検出
assert(message == "Update available: 3.0.0 -> 4.0.0")

// Bad: 部分一致 - 不正なメッセージでもパスする可能性
assert(message.contains("3.0.0"))
```

**理由:**
- 完全一致はメッセージフォーマットの意図しない変更を検出
- 部分一致はメッセージが根本的に間違っていてもパスする可能性
- テストは仕様として機能 - 完全一致は期待される出力を正確にドキュメント化

### 個別フィールドではなく構造体全体を比較

構造体をテストする際は、個別フィールドではなく構造体全体を比較：

```
// Good: 構造体全体を比較 - 欠落や不正なフィールドを検出
assert(result == expected_struct)

// Bad: 個別フィールドのアサーション - 不正なフィールドを見逃す可能性
assert(result.name == "lodash")
assert(result.version == "4.17.21")
```

**理由:**
- 構造体全体の比較は任意のフィールドの変更を検出
- 個別フィールドのアサーションは新規追加や変更されたフィールドを見逃す可能性
- テストは期待される出力の完全な仕様として機能

## モックと外部依存

### 実際の実装を優先

可能な限り実際の実装を使用。モックは以下の場合のみ：
- 外部ネットワーク呼び出し
- 分離が必要なファイルシステム操作
- 時間依存の振る舞い
- 非決定的な操作

## パラメータ化テスト

### パラメータ化を検討するタイミング

- 同じ関数に対して2つ以上のテストを書いた後
- TDDのREFACTORフェーズ中

### パラメータ化テストに変換する条件

**変換する場合:**
- テスト構造が同一（setup → execute → assertパターン）
- 入力値と期待される出力のみが異なる
- 複数のテストが異なるデータで同じ振る舞いを検証

**変換しない場合:**
- テストのセットアップロジックがケース間で大きく異なる
- テストが異なる振る舞いを検証（単なる異なる入力ではない）
- 各テストが固有のアサーションやエラーハンドリングを必要とする

## テスト構造パターン

### AAA (Arrange-Act-Assert) パターン

すべてのテストはAAAパターンに従う：

```javascript
test('should calculate total with tax', () => {
  // Arrange: テストデータと前提条件をセットアップ
  const cart = new ShoppingCart();
  cart.addItem({ price: 100, quantity: 2 });
  const taxRate = 0.1;

  // Act: テスト対象の動作を実行
  const total = cart.calculateTotal(taxRate);

  // Assert: 期待される結果を検証
  expect(total).toBe(220);
});
```

## 参照

- 言語別テスト命名規則: `references/test-naming.md`
- テストダブル（スタブ/モック/フェイク）: `references/test-doubles.md`
