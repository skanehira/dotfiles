"          __
"  __  __ /\_\    ___ ___   _ __   ___
" /\ \/\ \\/\ \ /' __` __`\/\`'__\/'___\
" \ \ \_/ |\ \ \/\ \/\ \/\ \ \ \//\ \__/
"  \ \___/  \ \_\ \_\ \_\ \_\ \_\\ \____\
"   \/__/    \/_/\/_/\/_/\/_/\/_/ \/____/

let g:mapleader = "\<Space>" " Leaderã‚­ãƒ¼ã‚’ã‚¹ãƒšãƒ¼ã‚¹ã«è¨­å®š

" ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šã‚’ãƒ­ãƒ¼ãƒ‰
exec 'source' expand('~/.plugin.vim')
syntax enable " ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚’æœ‰åŠ¹ã«ã™ã‚‹
filetype plugin indent on " ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼åˆ¥ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¨ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’æœ‰åŠ¹ã«ã™ã‚‹

" ã‚«ãƒ©ãƒ¼ã‚¹ã‚­ãƒ¼ãƒ ã‚’ä½¿ã† {{{
"colorscheme iceberg
let g:tokyonight_disable_italic_comment = 1
colorscheme tokyonight
" }}}

" ã‚ªãƒ—ã‚·ãƒ§ãƒ³ {{{
set encoding=utf-8
set fileencodings=utf-8,iso-2022-jp,euc-jp,sjis
set fileformats=unix,dos,mac
set belloff=all " ãƒŸãƒ¥ãƒ¼ãƒˆ
set backspace=2 " ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã¨Ctrl+hã§å‰Šé™¤ã‚’æœ‰åŠ¹ã«ã™ã‚‹
set smartindent autoindent " æ”¹è¡Œæ™‚è‡ªå‹•ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
set incsearch " ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã‚µãƒ¼ãƒã‚’æœ‰åŠ¹ã«ã™ã‚‹
set ignorecase " æ¤œç´¢æ™‚å¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„
set smartcase " æ¤œç´¢æ™‚ã«å¤§æ–‡å­—ã‚’å…¥åŠ›ã—ãŸå ´åˆignorecaseãŒç„¡åŠ¹ã«ãªã‚‹
set hlsearch " ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚µãƒ¼ãƒã‚’æœ‰åŠ¹ã«ã™ã‚‹
set undolevels=1000 " undoã§ãã‚‹æœ€å¤§æ•°
set scrolloff=100 " ã‚«ãƒ¼ã‚½ãƒ«ãŒå¸¸ã«ä¸­å¤®ã«æ¥ã‚‹ã‚ˆã†ã«ã™ã‚‹
set lazyredraw ttyfast " ãƒã‚¯ãƒ­ã§åŠ¹æœç™ºæ®
set synmaxcol=256 "ä¸€è¡ŒãŒé•·ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’syntaxã‚’åˆ¶å¾¡ã™ã‚‹ã“ã¨ã§è»½ãã™ã‚‹
set cursorline " ã‚«ãƒ¼ã‚½ãƒ«ãƒ©ã‚¤ãƒ³ã‚’è¡¨ç¤ºã™ã‚‹
set wildmenu " wildmenuã‚’æœ‰åŠ¹ã«ã™ã‚‹
set virtualedit=block " çŸ©å½¢é¸æŠæ™‚ã«æ–‡å­—ã®ç„¡ã„ã¨ã“ã‚ã¾ã§é¸æŠç¯„å›²ã‚’åºƒã’ã‚‹
set helplang=ja " ãƒ˜ãƒ«ãƒ—ã®è¨€èªã‚’æ—¥æœ¬èªå„ªå…ˆã«ã™ã‚‹
set autowrite " ä»–ã®ãƒãƒƒãƒ•ã‚¡ã«ç§»å‹•ã™ã‚‹æ™‚ã«è‡ªå‹•ä¿å­˜
set noswapfile " swapãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ãªã„
set showtabline=2 " ã‚¿ãƒ–ã‚’å¸¸ã«è¡¨ç¤º
set list listchars=tab:Â»-,trail:-,extends:Â»,precedes:Â«,nbsp:% " listã®è¨­å®š
if !has('nvim')
  set nrformats+=unsigned " æ•°å€¤ã®åŠ æ¸›ç®—ã‚’è€ƒæ…®
  set cursorlineopt=line " è¡Œã®ã¿ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  set sessionoptions=blank,buffers,curdir,folds,help,tabpages,winsize,terminal " ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§ä¿å­˜ã™ã‚‹å¯¾è±¡
endif
if has("mac") | set clipboard+=unnamed | else | set clipboard^=unnamedplus | endif " ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‚’å…±æœ‰

" æ‹¡å¼µå­ã”ã¨ã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆè¨­å®š {{{
augroup fileTypeIndent
  au!
  au FileType go setlocal tabstop=4 shiftwidth=4
  au FileType vim setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType php setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType html setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType javascript setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType typescript setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType vue  setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType yaml setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType json setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType sh setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType fish setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
augroup END
" }}}

" grepã—ãŸçµæœã‚’quickfixã«è¡¨ç¤ºã™ã‚‹ {{{
augroup grepwindow
  au!
  au QuickFixCmdPost *grep* cwindow
augroup END
" }}}

" ã‚«ãƒ¼ã‚½ãƒ«ãƒ©ã‚¤ãƒ³ã®ä½ç½®ã‚’ä¿å­˜ã™ã‚‹ {{{
augroup cursorlineRestore
  au!
  au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \   exe "normal! g'\"" |
        \ endif
augroup END
" }}}

" undoã®ä¿å­˜å…ˆ {{{
if has('persistent_undo')
  let undo_path = expand('~/.vim/undo')
  " ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
  if !isdirectory(undo_path)
    call mkdir(undo_path, 'p')
  endif
  exe 'set undodir=' .. undo_path
  set undofile
endif
" }}}
" }}}

" ã‚­ãƒ¼ãƒãƒƒãƒ— {{{
imap <C-h> <BS>

" *ã§ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç§»å‹•ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
noremap * *N

" ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã¨çµ‚äº†
nnoremap <Leader>w :w<CR>

" æ¤œç´¢
nnoremap <C-G><C-G> :Grep <C-R><C-W><CR>

" ç½®æ›
nnoremap <Leader>re :%s;\<<C-R><C-W>\>;g<Left><Left>;

" ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’å‰Šé™¤ã™ã‚‹
nnoremap <silent> <Esc><Esc> :nohlsearch<CR>

" vimrcã‚’é–‹ã
nnoremap <Leader>. :new ~/.vimrc<CR>
nnoremap <Leader>s :source ~/.vimrc<CR>

" ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚­ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚° {{{
onoremap 8 i(
onoremap 2 i"
onoremap 7 i'
onoremap @ i`
onoremap [ i[
onoremap { i{

onoremap a8 a(
onoremap a2 a"
onoremap a7 a'
onoremap a@ a`
onoremap a[ a[
onoremap a{ a{

" visual
nnoremap v8 vi(
nnoremap v2 vi"
nnoremap v7 vi'
nnoremap v@ vi`
nnoremap v[ vi[
nnoremap v{ vi{

nnoremap va8 va(
nnoremap va2 va"
nnoremap va7 va'
nnoremap va@ va`
nnoremap va[ va[
nnoremap va{ va{
" }}}

" è¡Œå…ˆé ­ã¨è¡Œæœ«
noremap H ^
noremap L g_

" ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
nnoremap <C-l> gt
nnoremap <C-h> gT

" ã‚¿ãƒ¼ãƒŸãƒŠãƒ«é–¢é€£ {{{
" ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ãƒãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰
tnoremap <C-w>n <C-w>N

" ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ç§»å‹•
tnoremap <silent> <C-j> <C-w>:tabnext<CR>
tnoremap <silent> <C-k> <C-w>:tabprevious<CR>

" <c-g>ã‚’<c-w>ä»£ã‚ã‚Šã«ã™ã‚‹
tnoremap <C-g> <C-w>.
" }}}

" review
augroup review
  au!
  au FileType review vnoremap <silent> <buffer> <Leader>hi c@<cursor>{<c-r>"}<esc>
augroup END

" æ”¹è¡Œ
nnoremap <C-j> o<ESC>
nnoremap <C-k> O<ESC>
nnoremap o A<CR>

" æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ã§ã®ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•
inoremap <silent> <C-f> <Right>
inoremap <silent> <C-b> <Left>
inoremap <silent> <C-e> <Esc>A
inoremap <silent> <C-a> <Esc>I

" å›²ã†
nnoremap <silent> gw[ cw``<Esc>P
vnoremap <silent> gw[ c``<Esc>P

" ãƒ˜ãƒ«ãƒ—
augroup help-mapping
  au!
  au FileType help nnoremap <buffer> <silent>q :bw!<CR>
augroup END

" }}}

" ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã§å˜èªç§»å‹• {{{
cnoremap <c-b> <Left>
cnoremap <c-f> <Right>
cnoremap <c-a> <Home>
" }}}

" Better <C-n>/<C-p> in Command {{{
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <Up> <C-p>
cnoremap <Down> <C-n>
" }}}

" profiling {{{
" vim +'call ProfileCursorMove()' <ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‹•ã‹ã™ã®ãŒé‡ã„ãƒ•ã‚¡ã‚¤ãƒ«>
function! ProfileCursorMove() abort
  let profile_file = expand('./vim-profile.log')
  if filereadable(profile_file)
    call delete(profile_file)
  endif

  normal! ggzR

  execute 'profile start ' . profile_file
  profile func *
  profile file *

  augroup ProfileCursorMove
    au!
    au CursorHold <buffer> profile pause | q
  augroup END

  for i in range(1000)
    call feedkeys('j')
  endfor
endfunction
" }}}

" {{{ ãƒ¬ã‚¸ã‚¹ã‚¿ã‚¯ãƒªã‚¢
function! s:clear_register() abort
  let rs = split('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789/-"', '\zs')
  for r in rs
    call setreg(r, [])
  endfor
endfunction
command! ClearRegister call s:clear_register()
" }}}

" {{{ w3m
function! s:gg(package) abort
  execute('term ++close ++shell w3m pkg.go.dev/' . a:package)
endfunction
function! s:www(word) abort
  execute('term ++close ++shell w3m google.com/search\?q="' . a:word . '"')
endfunction

command! -nargs=1 GG call s:gg(<f-args>)
command! -nargs=1 WWW call s:www(<f-args>)
" }}}

" {{{ ãƒªãƒã‚¸ãƒˆãƒªã«ç§»å‹•
function! s:cd_repo(shell, repo) abort
  exe 'lcd' trim(system('ghq root')) .. '/' .. a:repo
  pwd
endfunction

function! s:repo(cb) abort
  if executable('ghq') && exists('*fzf#run()') && executable('fzf')
    call fzf#run({
          \ 'source': systemlist('ghq list'),
          \ 'sink': a:cb,
          \ 'down': '40%'},
          \ )
  else
    echo "doesn't installed ghq or fzf.vim(require fzf)"
  endif
endfunction

command! Repo call s:repo(function('s:cd_repo', [&shell]))
" }}}

" {{{ ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡ºåŠ›
function! s:echo_err(message) abort
  echohl ErrorMsg
  redraw
  echo a:message
  echohl None
endfunction
" }}}

" {{{ gitã‚³ãƒãƒ³ãƒ‰é–¢é€£
" options:
" {
"	cmd: 'diff'
"	args: [
"		'HEAD^',
"	],
"	auto_close: 0,	" 1: true, 0: false
"	window_way: 'bo',	" tab, bo, vert, term, etc...
"	mode: 'term', " term, popup, fzf
"	focus: 1008, " window id
"	source: [], " fzf source
"	cb: functionm "fzf callback
" }
function! s:git_exec(opt) abort
  let current_winid = win_getid()
  if a:opt.mode is# 'term'
    let cmd = 'git ' .. a:opt.cmd
    if has_key(a:opt, 'args') && !empty(a:opt.args)
      let cmd = cmd .. ' ' .. join(a:opt.args, ' ')
    endif
    if has_key(a:opt, 'auto_close') && a:opt.auto_close is# 1
      let cmd = a:opt.window_way .. ' term ++rows=10 ++close ' .. cmd
    else
      let cmd = a:opt.window_way .. ' term ++rows=10 ' .. cmd
    endif
    exec cmd
    nnoremap <buffer> <silent> q :bw!<CR>
  elseif a:opt.mode is# 'pop'
    " TODO use popup window
  elseif a:opt.mode is# 'fzf'
    if exists('*fzf#run()') && executable('fzf')
      call fzf#run({
            \ 'source': a:opt.source,
            \ 'sink': a:opt.cb,
            \ 'down': '40%'},
            \ )
    endif
  else
    call s:echo_err("doesn't installed fzf.vim(require fzf)")
  endif

  call win_gotoid(current_winid)
endfunction

function! s:git_log() abort
  " use fish command
  call system('tmux new-window git log')
endfunction

function! s:git_push(...) abort
  let opt = {
        \ 'cmd': 'push',
        \ 'args': a:000,
        \ 'auto_close': 0,
        \ 'window_way': 'top',
        \ 'mode': 'term',
        \ }

  call s:git_exec(opt)
endfunction

function! s:git_pull(...) abort
  let opt = {
        \ 'cmd': 'pull',
        \ 'args': a:000,
        \ 'auto_close': 0,
        \ 'window_way': 'top',
        \ 'mode': 'term',
        \ }

  call s:git_exec(opt)
endfunction

function! s:git_checkout_cb(repo) abort
  call system('git checkout' .. a:repo)
endfunction

function! s:git_checkout(...) abort
  let source = filter(systemlist('git branch'), 'v:val[0] isnot# "*"')
  if empty(source)
    call s:echo_err("no other branch")
    return
  endif

  let opt = {
        \ 'source': source,
        \ 'mode': 'fzf',
        \ 'cb': function('s:git_checkout_cb'),
        \ }

  call s:git_exec(opt)
endfunction

command! -nargs=* Gitpush call s:git_push(<f-args>)
command! -nargs=* Gitpull call s:git_pull()
" }}}

" {{{ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªè‡ªå‹•ç”Ÿæˆ
function! s:auto_mkdir(dir)
  if !isdirectory(a:dir)
    call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
  endif
endfunction
augroup auto-mkdir
  au!
  au BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'))
augroup END
" }}}

" {{{ ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ãƒãƒƒãƒ•ã‚¡
" eg. vnew term://bsah ã§ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚’å®Ÿè¡Œ
function! s:termopen() abort
  let name = split(bufname(), '\/\/')
  if len(name) < 2
    return
  endif
  call execute(printf('term ++curwin ++close ++shell %s', name[1]))
endfunction

augroup terminal
  au!
  au BufReadCmd term://* call s:termopen()
augroup END
" }}}

" {{{ ç”»åƒä»˜ããƒ„ã‚¤ãƒ¼ãƒˆ
function! s:on_err_vim(ch, msg) abort
  call s:echo_err(a:msg)
endfunction

function! s:exit_twty_cb(tmp_img, tmp_tweet, ch, msg) abort
  call delete(a:tmp_img)
  call delete(a:tmp_tweet)
  echom 'tweet success'
endfunction

function! s:exit_code2imge_cb(tmp_img, tweet, tmp_code, ch, msg) abort
  call delete(a:tmp_code)

  let tmp_tweet = tempname()
  call writefile([a:tweet], tmp_tweet)

  call job_start(['twty', '-m', a:tmp_img, '-ff', '-'], {
        \ 'in_io': 'file',
        \ 'in_name': tmp_tweet,
        \ 'err_cb': function('s:on_err_vim'),
        \ 'exit_cb': function('s:exit_twty_cb', [a:tmp_img, tmp_tweet])
        \ })
endfunction

function! TweetWithImg(first, last, ...) abort
  let lines = getline(a:first, a:last)
  let tmp_code = printf("%s.%s", tempname(), &ft)
  call writefile(lines, tmp_code)

  let tmp_img = tempname()

  let cmd = ['code2img', '-l', '-t', 'solarized-dark', '-ext', &ft, '-o', tmp_img]

  call job_start(cmd, {
        \ 'in_io': 'file',
        \ 'in_name': tmp_code,
        \ 'err_cb': function('s:on_err_vim'),
        \ 'exit_cb': function('s:exit_code2imge_cb', [tmp_img, a:1, tmp_code])
        \ })
endfunction

command! -nargs=? -range TweetWithImg call TweetWithImg(<line1>, <line2>, <q-args>)
" }}}

" {{{ lazygit
nnoremap <silent> gp :call system('tmuxpopup lazygit')<CR>
" }}}

" {{{ golangci-lint
function! s:golangci(...) abort
  if !executable('golangci-lint')
    call s:echo_err('golangci-lint doesn''t installed')
    return
  endif

  if a:0 > 0
    let opts = a:000
  else
    let opts = get(g:, 'golangci_opts', ['misspell', 'unparam', 'stylecheck',
          \ 'gosec', 'prealloc', 'scopelint', 'gocritic', 'gomnd', 'unconvert'])
  endif

  if get(g:, 'golangci_disable_all', 0)
    let cmd = printf('golangci-lint run --disable-all --print-issued-lines=false --enable=%s', join(opts, ','))
  else
    let cmd = printf('golangci-lint run --print-issued-lines=false --enable=%s', join(opts, ','))
  endif
  cexpr system(cmd) | cw
endfunction
command! -nargs=* GolangCI call <SID>golangci(<f-args>)
" }}}

" {{{ grep
function! s:grep(word) abort
  let cmd = printf('ag -S %s', a:word)
  cgetexpr system(cmd) | cw
endfunction

command! -nargs=1 Grep call <SID>grep(<q-args>)
" }}}

" {{{ zenn
function! s:create_zenn_article(article_name) abort
  let date = strftime("%Y-%m-%d")
  let slug = date . "-" . a:article_name
  call system("npx zenn new:article --emoji ğŸ¦ --slug " . slug )
  let article_path = "articles/" . slug . ".md"
  exe "edit " . article_path
endfunction

command! -nargs=1 ZennCreateArticle call <SID>create_zenn_article(<f-args>)
" }}}

" vim: foldmethod=marker
