"          __
"  __  __ /\_\    ___ ___   _ __   ___
" /\ \/\ \\/\ \ /' __` __`\/\`'__\/'___\
" \ \ \_/ |\ \ \/\ \/\ \/\ \ \ \//\ \__/
"  \ \___/  \ \_\ \_\ \_\ \_\ \_\\ \____\
"   \/__/    \/_/\/_/\/_/\/_/\/_/ \/____/

let g:mapleader = "\<Space>" " Leader„Ç≠„Éº„Çí„Çπ„Éö„Éº„Çπ„Å´Ë®≠ÂÆö

" „Éó„É©„Ç∞„Ç§„É≥Ë®≠ÂÆö„Çí„É≠„Éº„Éâ
exec 'source' expand('~/.plugin.vim')
syntax enable " „Ç∑„É≥„Çø„ÉÉ„ÇØ„Çπ„ÇíÊúâÂäπ„Å´„Åô„Çã
filetype plugin indent on " „Éï„Ç°„Ç§„É´ÂΩ¢ÂºèÂà•„Éó„É©„Ç∞„Ç§„É≥„Å®„Ç§„É≥„Éá„É≥„Éà„ÇíÊúâÂäπ„Å´„Åô„Çã

" „Ç´„É©„Éº„Çπ„Ç≠„Éº„É†„Çí‰Ωø„ÅÜ {{{
colorscheme iceberg
" iceberg„ÅØ„Çø„Éº„Éü„Éä„É´„Çí16Ëâ≤„Å´Ë®≠ÂÆö„Åô„Çã„ÅÆ„ÇíÂõûÈÅø
if !has('nvim')
  augroup iceberg
    au!
    au ColorScheme * unlet g:terminal_ansi_colors
  augroup END
endif
set background=dark
"let g:tokyonight_disable_italic_comment = 1
"colorscheme tokyonight
" }}}

" „Ç™„Éó„Ç∑„Éß„É≥ {{{
set encoding=utf-8
set t_ut=
set fileencodings=utf-8,iso-2022-jp,euc-jp,sjis
set fileformats=unix,dos,mac
set belloff=all " „Éü„É•„Éº„Éà
set backspace=2 " „Éê„ÉÉ„ÇØ„Çπ„Éö„Éº„Çπ„Å®Ctrl+h„ÅßÂâäÈô§„ÇíÊúâÂäπ„Å´„Åô„Çã
set smartindent autoindent " ÊîπË°åÊôÇËá™Âãï„Ç§„É≥„Éá„É≥„Éà
set incsearch " „Ç§„É≥„ÇØ„É™„É°„É≥„Éà„Çµ„Éº„ÉÅ„ÇíÊúâÂäπ„Å´„Åô„Çã
set ignorecase " Ê§úÁ¥¢ÊôÇÂ§ßÊñáÂ≠óÂ∞èÊñáÂ≠ó„ÇíÂå∫Âà•„Åó„Å™„ÅÑ
set smartcase " Ê§úÁ¥¢ÊôÇ„Å´Â§ßÊñáÂ≠ó„ÇíÂÖ•Âäõ„Åó„ÅüÂ†¥Âêàignorecase„ÅåÁÑ°Âäπ„Å´„Å™„Çã
set hlsearch " „Éè„Ç§„É©„Ç§„Éà„Çµ„Éº„ÉÅ„ÇíÊúâÂäπ„Å´„Åô„Çã
set undolevels=1000 " undo„Åß„Åç„ÇãÊúÄÂ§ßÊï∞
set scrolloff=100 " „Ç´„Éº„ÇΩ„É´„ÅåÂ∏∏„Å´‰∏≠Â§Æ„Å´Êù•„Çã„Çà„ÅÜ„Å´„Åô„Çã
set lazyredraw ttyfast " „Éû„ÇØ„É≠„ÅßÂäπÊûúÁô∫ÊèÆ
set synmaxcol=256 "‰∏ÄË°å„ÅåÈï∑„ÅÑ„Éï„Ç°„Ç§„É´„Çísyntax„ÇíÂà∂Âæ°„Åô„Çã„Åì„Å®„ÅßËªΩ„Åè„Åô„Çã
set cursorline " „Ç´„Éº„ÇΩ„É´„É©„Ç§„É≥„ÇíË°®Á§∫„Åô„Çã
set wildmenu " wildmenu„ÇíÊúâÂäπ„Å´„Åô„Çã
set virtualedit=block " Áü©ÂΩ¢ÈÅ∏ÊäûÊôÇ„Å´ÊñáÂ≠ó„ÅÆÁÑ°„ÅÑ„Å®„Åì„Çç„Åæ„ÅßÈÅ∏ÊäûÁØÑÂõ≤„ÇíÂ∫É„Åí„Çã
set helplang=ja " „Éò„É´„Éó„ÅÆË®ÄË™û„ÇíÊó•Êú¨Ë™ûÂÑ™ÂÖà„Å´„Åô„Çã
set autowrite " ‰ªñ„ÅÆ„Éê„ÉÉ„Éï„Ç°„Å´ÁßªÂãï„Åô„ÇãÊôÇ„Å´Ëá™Âãï‰øùÂ≠ò
set noswapfile " swap„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê„Åó„Å™„ÅÑ
set showtabline=2 " „Çø„Éñ„ÇíË°®Á§∫„Åó„Å™„ÅÑ
set noshowmode
set laststatus=2
set list listchars=tab:¬ª-,trail:-,extends:¬ª,precedes:¬´,nbsp:% " list„ÅÆË®≠ÂÆö
if !has('nvim')
  set nrformats+=unsigned " Êï∞ÂÄ§„ÅÆÂä†Ê∏õÁÆó„ÇíËÄÉÊÖÆ
  set cursorlineopt=line " Ë°å„ÅÆ„Åø„Éè„Ç§„É©„Ç§„Éà
  set sessionoptions=blank,buffers,curdir,folds,help,tabpages,winsize,terminal " „Çª„ÉÉ„Ç∑„Éß„É≥„Åß‰øùÂ≠ò„Åô„ÇãÂØæË±°
endif
if has("mac") | set clipboard+=unnamed | else | set clipboard^=unnamedplus | endif " „ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„ÇíÂÖ±Êúâ

" Êã°ÂºµÂ≠ê„Åî„Å®„ÅÆ„Ç§„É≥„Éá„É≥„ÉàË®≠ÂÆö {{{
augroup fileTypeIndent
  au!
  au FileType go setlocal tabstop=4 shiftwidth=4
  au FileType vim setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType php setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType html setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType javascript setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType typescript setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType vue  setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType yaml setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType json setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType sh setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType fish setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
  au FileType rust setlocal tabstop=4 softtabstop=4 shiftwidth=4 expandtab
  au FileType markdown setlocal tabstop=2 shiftwidth=2
augroup END
" }}}

" {{{ „Ç∑„É≥„Çø„ÉÉ„ÇØ„Çπ„Çí„ÇØ„É™„Ç¢
augroup fileTypeSyntaxClear
  au!
  au FileType go syntax clear
  au FileType vim syntax clear
  au FileType html syntax clear
  au FileType javascript syntax clear
  au FileType typescript syntax clear
  au FileType vue  syntax clear
augroup END
" }}}

" grep„Åó„ÅüÁµêÊûú„Çíquickfix„Å´Ë°®Á§∫„Åô„Çã {{{
augroup grepwindow
  au!
  au QuickFixCmdPost *grep* cwindow
augroup END
" }}}

" „Ç´„Éº„ÇΩ„É´„É©„Ç§„É≥„ÅÆ‰ΩçÁΩÆ„Çí‰øùÂ≠ò„Åô„Çã {{{
augroup cursorlineRestore
  au!
  au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \   exe "normal! g'\"" |
        \ endif
augroup END
" }}}

" undo„ÅÆ‰øùÂ≠òÂÖà {{{
if has('persistent_undo')
  let undo_path = expand('~/.vim/undo')
  " „Éá„Ç£„É¨„ÇØ„Éà„É™„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ‰ΩúÊàê
  if !isdirectory(undo_path)
    call mkdir(undo_path, 'p')
  endif
  exe 'set undodir=' .. undo_path
  set undofile
endif
" }}}
" }}}

" „Ç≠„Éº„Éû„ÉÉ„Éó {{{
" *„Åß„Ç´„Éº„ÇΩ„É´„ÇíÁßªÂãï„Åó„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã
noremap * *N

" „Éï„Ç°„Ç§„É´‰øùÂ≠ò„Å®ÁµÇ‰∫Ü
nnoremap <Leader>w :w<CR>

" Ê§úÁ¥¢
nnoremap <C-G><C-G> :Grep <C-R><C-W><CR>

" ÁΩÆÊèõ
nnoremap <Leader>re :%s;\<<C-R><C-W>\>;g<Left><Left>;

" „Éè„Ç§„É©„Ç§„Éà„ÇíÂâäÈô§„Åô„Çã
nnoremap <silent> <Esc><Esc> :nohlsearch<CR>

" vimrc„ÇíÈñã„Åè
nnoremap <Leader>. :new ~/.vimrc<CR>
nnoremap <Leader>s :source ~/.vimrc<CR>

" „ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Ç≠„Éº„Éû„ÉÉ„Éî„É≥„Ç∞ {{{
onoremap 8 i(
onoremap 2 i"
onoremap 7 i'
onoremap @ i`
onoremap [ i[
onoremap { i{

onoremap a8 a(
onoremap a2 a"
onoremap a7 a'
onoremap a@ a`
onoremap a[ a[
onoremap a{ a{

" visual
nnoremap v8 vi(
nnoremap v2 vi"
nnoremap v7 vi'
nnoremap v@ vi`
nnoremap v[ vi[
nnoremap v{ vi{

nnoremap va8 va(
nnoremap va2 va"
nnoremap va7 va'
nnoremap va@ va`
nnoremap va[ va[
nnoremap va{ va{
" }}}

" Ë°åÂÖàÈ†≠„Å®Ë°åÊú´
noremap H ^
noremap L g_

" „Çø„ÉñÂàá„ÇäÊõø„Åà
nnoremap <C-l> gt
nnoremap <C-h> gT

" „Çø„Éº„Éü„Éä„É´Èñ¢ÈÄ£ {{{
tnoremap <Esc> <C-\><C-n>
if has('nvim')
  function! s:term_start(cmd) abort
    call termopen(a:cmd)
  endfunction
else
  function! s:term_start(cmd) abort
    exe printf('term ++curwin ++shell %s', a:cmd)
    nnoremap <buffer> <silent> <CR> :bw<CR>
  endfunction
endif

function! s:termopen() abort
  let bufname = bufname()
  let parts = split(bufname, ' ')
  let cmd = &shell
  if len(parts) > 1
    " like :new te* [command] [args]
    let cmd = join(parts[1:], " ")
  endif
  call s:term_start(cmd)
endfunction

if has('nvim')
  augroup neovim-terminal
    au!
    au TermOpen * startinsert
  augroup END
else
  set termwinkey=<C-]>
  " „Çø„Éº„Éü„Éä„É´„Éé„Éº„Éû„É´„É¢„Éº„Éâ
endif

augroup terminal
  au!
  au BufNewFile te* ++nested call s:termopen()
augroup END
" }}}

" review
augroup review
  au!
  au FileType review vnoremap <silent> <buffer> <Leader>hi c@<cursor>{<c-r>"}<esc>
augroup END

" ÊîπË°å
nnoremap <C-j> o<ESC>
nnoremap <C-k> O<ESC>
nnoremap o A<CR>

" EmacsÈ¢®„ÅÆ„Ç≠„Éº„Éû„ÉÉ„Éó
imap <C-h> <BS>
inoremap <C-k> <C-o>C
inoremap <silent> <C-f> <Right>
inoremap <silent> <C-b> <Left>
inoremap <silent> <C-e> <C-o>A
inoremap <silent> <C-a> <C-o>I

" C-v „Åß„Éö„Éº„Çπ„Éà
inoremap <expr> <C-v> printf('<C-r><C-o>%s', has('linux') \|\| has('unix') ? '+' : '*')
cnoremap <expr> <C-v> printf('<C-r><C-o>%s', has('linux') \|\| has('unix') ? '+' : '*')

" Âõ≤„ÅÜ
nnoremap <silent> gw[ cw``<Esc>P
vnoremap <silent> gw[ c``<Esc>P

" „Éò„É´„Éó
augroup help-mapping
  au!
  au FileType help nnoremap <buffer> <silent>q :bw!<CR>
augroup END

" }}}

" „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„ÅßÂçòË™ûÁßªÂãï {{{
cnoremap <c-b> <Left>
cnoremap <c-f> <Right>
cnoremap <c-a> <Home>
" }}}

" Better <C-n>/<C-p> in Command {{{
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <Up> <C-p>
cnoremap <Down> <C-n>
" }}}

" profiling {{{
" vim +'call ProfileCursorMove()' <„Ç´„Éº„ÇΩ„É´„ÇíÂãï„Åã„Åô„ÅÆ„ÅåÈáç„ÅÑ„Éï„Ç°„Ç§„É´>
function! ProfileCursorMove() abort
  let profile_file = expand('./vim-profile.log')
  if filereadable(profile_file)
    call delete(profile_file)
  endif

  normal! ggzR

  execute 'profile start ' . profile_file
  profile func *
  profile file *

  augroup ProfileCursorMove
    au!
    au CursorHold <buffer> profile pause | q
  augroup END

  for i in range(1000)
    call feedkeys('j')
  endfor
endfunction
" }}}

" {{{ „É¨„Ç∏„Çπ„Çø„ÇØ„É™„Ç¢
function! s:clear_register() abort
  let rs = split('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789/-"', '\zs')
  for r in rs
    call setreg(r, [])
  endfor
endfunction
command! ClearRegister call s:clear_register()
" }}}

" {{{ w3m
function! s:gg(package) abort
  execute('term ++close ++shell w3m pkg.go.dev/' . a:package)
endfunction
function! s:www(word) abort
  execute('term ++close ++shell w3m google.com/search\?q="' . a:word . '"')
endfunction

command! -nargs=1 GG call s:gg(<f-args>)
command! -nargs=1 WWW call s:www(<f-args>)
" }}}

" {{{ „É™„Éù„Ç∏„Éà„É™„Å´ÁßªÂãï
function! s:cd_repo(shell, repo) abort
  exe 'lcd' trim(system('ghq root')) .. '/' .. a:repo
  pwd
endfunction

function! s:repo(cb) abort
  if executable('ghq') && exists('*fzf#run()') && executable('fzf')
    call fzf#run({
          \ 'source': systemlist('ghq list'),
          \ 'sink': a:cb,
          \ 'down': '40%'},
          \ )
  else
    echo "doesn't installed ghq or fzf.vim(require fzf)"
  endif
endfunction

command! Repo call s:repo(function('s:cd_repo', [&shell]))
" }}}

" {{{ „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏Âá∫Âäõ
function! s:echo_err(message) abort
  echohl ErrorMsg
  redraw
  echo a:message
  echohl None
endfunction
" }}}

" {{{ git„Ç≥„Éû„É≥„ÉâÈñ¢ÈÄ£
" options:
" {
"	cmd: 'diff'
"	args: [
"		'HEAD^',
"	],
"	auto_close: 0,	" 1: true, 0: false
"	window_way: 'bo',	" tab, bo, vert, term, etc...
"	mode: 'term', " term, popup, fzf
"	focus: 1008, " window id
"	source: [], " fzf source
"	cb: functionm "fzf callback
" }
function! s:git_exec(opt) abort
  let current_winid = win_getid()
  if a:opt.mode is# 'term'
    let cmd = 'git ' .. a:opt.cmd
    if has_key(a:opt, 'args') && !empty(a:opt.args)
      let cmd = cmd .. ' ' .. join(a:opt.args, ' ')
    endif
    if has_key(a:opt, 'auto_close') && a:opt.auto_close is# 1
      let cmd = a:opt.window_way .. ' term ++rows=10 ++close ' .. cmd
    else
      let cmd = a:opt.window_way .. ' term ++rows=10 ' .. cmd
    endif
    exec cmd
    nnoremap <buffer> <silent> q :bw!<CR>
  elseif a:opt.mode is# 'pop'
    " TODO use popup window
  elseif a:opt.mode is# 'fzf'
    if exists('*fzf#run()') && executable('fzf')
      call fzf#run({
            \ 'source': a:opt.source,
            \ 'sink': a:opt.cb,
            \ 'down': '40%'},
            \ )
    endif
  else
    call s:echo_err("doesn't installed fzf.vim(require fzf)")
  endif

  call win_gotoid(current_winid)
endfunction

function! s:git_log() abort
  " use fish command
  call system('tmux new-window git log')
endfunction

function! s:git_push(...) abort
  let opt = {
        \ 'cmd': 'push',
        \ 'args': a:000,
        \ 'auto_close': 0,
        \ 'window_way': 'top',
        \ 'mode': 'term',
        \ }

  call s:git_exec(opt)
endfunction

function! s:git_pull(...) abort
  let opt = {
        \ 'cmd': 'pull',
        \ 'args': a:000,
        \ 'auto_close': 0,
        \ 'window_way': 'top',
        \ 'mode': 'term',
        \ }

  call s:git_exec(opt)
endfunction

function! s:git_checkout_cb(repo) abort
  call system('git checkout' .. a:repo)
endfunction

function! s:git_checkout(...) abort
  let source = filter(systemlist('git branch'), 'v:val[0] isnot# "*"')
  if empty(source)
    call s:echo_err("no other branch")
    return
  endif

  let opt = {
        \ 'source': source,
        \ 'mode': 'fzf',
        \ 'cb': function('s:git_checkout_cb'),
        \ }

  call s:git_exec(opt)
endfunction

command! -nargs=* Gitpush call s:git_push(<f-args>)
command! -nargs=* Gitpull call s:git_pull()
" }}}

" {{{ „Éá„Ç£„É¨„ÇØ„Éà„É™Ëá™ÂãïÁîüÊàê
function! s:auto_mkdir(dir)
  if !isdirectory(a:dir)
    call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
  endif
endfunction
augroup auto-mkdir
  au!
  au BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'))
augroup END
" }}}

" {{{ ÁîªÂÉè‰ªò„Åç„ÉÑ„Ç§„Éº„Éà
function! s:on_err_vim(ch, msg) abort
  call s:echo_err(a:msg)
endfunction

function! s:exit_twty_cb(tmp_img, tmp_tweet, ch, msg) abort
  call delete(a:tmp_img)
  call delete(a:tmp_tweet)
  echom 'tweet success'
endfunction

function! s:exit_code2imge_cb(tmp_img, tweet, tmp_code, ch, msg) abort
  call delete(a:tmp_code)

  let tmp_tweet = tempname()
  call writefile([a:tweet], tmp_tweet)

  call job_start(['twty', '-m', a:tmp_img, '-ff', '-'], {
        \ 'in_io': 'file',
        \ 'in_name': tmp_tweet,
        \ 'err_cb': function('s:on_err_vim'),
        \ 'exit_cb': function('s:exit_twty_cb', [a:tmp_img, tmp_tweet])
        \ })
endfunction

function! TweetWithImg(first, last, ...) abort
  let lines = getline(a:first, a:last)
  let tmp_code = printf("%s.%s", tempname(), &ft)
  call writefile(lines, tmp_code)

  let tmp_img = tempname()

  let cmd = ['code2img', '-l', '-t', 'solarized-dark', '-ext', &ft, '-o', tmp_img]

  call job_start(cmd, {
        \ 'in_io': 'file',
        \ 'in_name': tmp_code,
        \ 'err_cb': function('s:on_err_vim'),
        \ 'exit_cb': function('s:exit_code2imge_cb', [tmp_img, a:1, tmp_code])
        \ })
endfunction

command! -nargs=? -range TweetWithImg call TweetWithImg(<line1>, <line2>, <q-args>)
" }}}

" {{{ lazygit
nnoremap <silent> gp :call system('tmuxpopup tig')<CR>
" }}}

" {{{ golangci-lint
function! s:golangci(...) abort
  if !executable('golangci-lint')
    call s:echo_err('golangci-lint doesn''t installed')
    return
  endif

  if a:0 > 0
    let opts = a:000
  else
    let opts = get(g:, 'golangci_opts', ['misspell', 'unparam', 'stylecheck',
          \ 'gosec', 'prealloc', 'gocritic', 'gomnd', 'unconvert'])
  endif

  if get(g:, 'golangci_disable_all', 0)
    let cmd = printf('golangci-lint run --disable-all --print-issued-lines=false --enable=%s', join(opts, ','))
  else
    let cmd = printf('golangci-lint run --print-issued-lines=false --enable=%s', join(opts, ','))
  endif
  cexpr system(cmd) | cw
endfunction
command! -nargs=* GolangCI call <SID>golangci(<f-args>)
" }}}

" {{{ grep
function! s:grep(word) abort
  let cmd = printf('ag -S %s', a:word)
  cgetexpr system(cmd) | cw
endfunction

command! -nargs=1 Grep call <SID>grep(<q-args>)
" }}}

" {{{ zenn
function! s:create_zenn_article(article_name) abort
  let date = strftime("%Y-%m-%d")
  let slug = date . "-" . a:article_name
  call system("npx zenn new:article --emoji ü¶ç --slug " . slug )
  let article_path = "articles/" . slug . ".md"
  exe "edit " . article_path
endfunction

command! -nargs=1 ZennCreateArticle call <SID>create_zenn_article(<f-args>)
" }}}

" {{{ goimports
augroup enterd-go
  function! s:goimports() abort
    let pos = getcurpos()
    %!goimports
    call setpos('.', pos)
  endfunction
  au!
  au! FileType go nnoremap <silent> <Leader>i :call <SID>goimports()<CR>
augroup END
" }}}

" {{{ git diff log
function! s:get_currentline_diff() abort
  let lnum = getcurpos()[1]
  let fname = expand('%:p')
  vnew git-diff
  set ft=git
  nnoremap <buffer> <silent> q :bw!<CR>
  let result = systemlist(printf('git log -L %d,%d:%s', lnum, lnum, fname))
  call setline(1, result)
endfunction

command! GitDiffLog call <SID>get_currentline_diff()
" }}}

function! s:swagger_preview(file) abort
  if !executable('spr')
    call echo_err('spr deosn''t installed')
  endif

  let s:swagger_preview_jobid = job_start(['spr', a:file])
endfunction

function! s:swagger_preview_stop() abort
  call job_stop(s:swagger_preview_jobid)
endfunction

command! -nargs=1 -complete=file SwaggerPreview call <SID>swagger_preview(<f-args>)
command! SwaggerPreviewStop call <SID>swagger_preview_stop()

" vim: foldmethod=marker
