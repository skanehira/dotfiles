"          __
"  __  __ /\_\    ___ ___   _ __   ___
" /\ \/\ \\/\ \ /' __` __`\/\`'__\/'___\
" \ \ \_/ |\ \ \/\ \/\ \/\ \ \ \//\ \__/
"  \ \___/  \ \_\ \_\ \_\ \_\ \_\\ \____\
"   \/__/    \/_/\/_/\/_/\/_/\/_/ \/____/

" vimrcã§ãƒãƒ«ãƒãƒã‚¤ãƒˆæ–‡å­—ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãŸã‚è¨­å®š {{{
scriptencoding utf-8
" }}}

" dein.vim settings {{{
" install dir {{{
let s:dein_dir = expand('~/.cache/dein')
let s:dein_repo_dir = s:dein_dir . '/repos/github.com/Shougo/dein.vim'
" }}}

" dein installation check {{{
if &runtimepath !~# '/dein.vim'
	if !isdirectory(s:dein_repo_dir)
		execute '!git clone https://github.com/Shougo/dein.vim' s:dein_repo_dir
	endif
	execute 'set runtimepath^=' . s:dein_repo_dir
endif
" }}}

" begin settings {{{
if dein#load_state(s:dein_dir)
	call dein#begin(s:dein_dir)

	" .toml file
	let s:rc_dir = expand('~/.vim')
	if !isdirectory(s:rc_dir)
		call mkdir(s:rc_dir, 'p')
	endif
	let s:toml = s:rc_dir . '/dein.toml'

	" read toml and cache
	call dein#load_toml(s:toml, {'lazy': 0})

	" end settings
	call dein#end()
	call dein#save_state()
endif
" }}}

" plugin installation check {{{
if dein#check_install()
	call dein#install()
endif
" }}}

" plugin remove check {{{
let s:removed_plugins = dein#check_clean()
if len(s:removed_plugins) > 0
	call map(s:removed_plugins, "delete(v:val, 'rf')")
	call dein#recache_runtimepath()
endif
" }}}

" }}}

" general settings {{{

" ãƒŸãƒ¥ãƒ¼ãƒˆ {{{
set belloff=all
" }}}

" æ–‡å­—ã‚³ãƒ¼ãƒ‰ {{{
set encoding=utf-8
set fileencodings=utf-8,iso-2022-jp,euc-jp,sjis
set fileformats=unix,dos,mac
" }}}

" https://vim-jp.org/vimdoc-ja/map.html#mapleader
" Leaderã‚­ãƒ¼ã‚’ã‚¹ãƒšãƒ¼ã‚¹ã«è¨­å®š {{{
let g:mapleader = "\<Space>"
" }}}

" ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ã‚’æœ‰åŠ¹ã«ã™ã‚‹ {{{
syntax enable
" }}}

" ã‚«ãƒ©ãƒ¼ã‚¹ã‚­ãƒ¼ãƒ ã‚’ä½¿ã† {{{
colorscheme iceberg
"colorscheme gotham256
" }}}

" https://vim-jp.org/vimdoc-ja/filetype.html#:filetype-plugin-on
" https://vim-jp.org/vimdoc-ja/filetype.html#:filetype-indent-on
" ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼åˆ¥ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¨ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’æœ‰åŠ¹ã«ã™ã‚‹ {{{
filetype plugin indent on
" }}}

" ãƒãƒƒã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã¨Ctrl+hã§å‰Šé™¤ã‚’æœ‰åŠ¹ã«ã™ã‚‹ {{{
set backspace=2
" }}}

" æ”¹è¡Œæ™‚è‡ªå‹•ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ {{{
set smartindent
set autoindent
" }}}

" è‡ªå‹•ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã®ç©ºç™½ã®æ•°
set shiftwidth=4
" }}}

" è¡Œç•ªå·ã‚’è¡¨ç¤º {{{
set number
" }}}

" ã‚«ãƒ¼ã‚½ãƒ«ã‹ã‚‰ç›¸å¯¾çš„ãªè¡Œæ•°ã‚’è¡¨ç¤ºã™ã‚‹ {{{
"set relativenumber
" }}}

"augroup numberToggle
"	au!
"	au InsertEnter * set relativenumber! | set number!
"	au InsertLeave * set relativenumber | set number
"augroup END

" https://vim-jp.org/vimdoc-ja/options.html#'tabstop'
" ã‚¿ãƒ–ã§ã‚‚å¸¸ã«ç©ºç™½ã‚’æŒ¿å…¥ {{{
set tabstop=4
set expandtab
" }}}

" ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã‚µãƒ¼ãƒã‚’æœ‰åŠ¹ã«ã™ã‚‹ {{{
set incsearch
" }}}

" https://vim-jp.org/vimdoc-ja/options.html#'ignorecase'
" æ¤œç´¢æ™‚å¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„ {{{
set ignorecase
" }}}

" https://vim-jp.org/vimdoc-ja/options.html#'smartcase'
" æ¤œç´¢æ™‚ã«å¤§æ–‡å­—ã‚’å…¥åŠ›ã—ãŸå ´åˆignorecaseãŒç„¡åŠ¹ã«ãªã‚‹ {{{
set smartcase
" }}}

" ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚µãƒ¼ãƒã‚’æœ‰åŠ¹ã«ã™ã‚‹ {{{
set hlsearch
" }}}

" undoã§ãã‚‹æœ€å¤§æ•° {{{
set undolevels=1000
" }}}

" mac os ã®ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‚’å…±æœ‰ {{{
set clipboard+=unnamed
" }}}

" ã‚«ãƒ¼ã‚½ãƒ«ãŒå¸¸ã«ä¸­å¤®ã«æ¥ã‚‹ã‚ˆã†ã«ã™ã‚‹ {{{
set scrolloff=100
" }}}

" ã‚¹ãƒ¯ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¾ã‚Œã‚‹æ™‚é–“(ãƒŸãƒªç§’å˜ä½) {{{
"set updatetime=450
" }}}

" ãƒã‚¯ãƒ­ã§åŠ¹æœç™ºæ® {{{
set lazyredraw
set ttyfast
" }}}

" ä¸€è¡ŒãŒé•·ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’syntaxã‚’åˆ¶å¾¡ã™ã‚‹ã“ã¨ã§è»½ãã™ã‚‹ {{{
set synmaxcol=256
" }}}

" ã‚«ãƒ¼ã‚½ãƒ«ãƒ©ã‚¤ãƒ³ã‚’è¡¨ç¤ºã™ã‚‹ {{{
set cursorline
if !has('nvim')
	set cursorlineopt=number
endif
" }}}

" https://vim-jp.org/vimdoc-ja/pi_netrw.html#g:netrw_liststyle
" netrwãƒ„ãƒªãƒ¼è¡¨ç¤ºã‚’æœ‰åŠ¹ã«ã™ã‚‹ {{{
let g:netrw_liststyle=3
let g:netrw_banner=0
let g:netrw_sizestyle='H'
let g:netrw_timefmt='%Y/%m/%d(%a) %H:%M:%S'
let g:netrw_preview=1
" }}}

" æ‹¡å¼µå­ã”ã¨ã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’æŒ‡å®šã™ã‚‹ {{{
augroup fileTypeIndent
	autocmd!
	au BufRead,BufNewFile *.php setlocal tabstop=4 softtabstop=4 shiftwidth=4
	au BufRead,BufNewFile *.html setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
	au BufRead,BufNewFile *.js   setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
	au BufRead,BufNewFile *.vue  setlocal tabstop=2 softtabstop=2 shiftwidth=2 expandtab
	au BufRead,BufNewFile *.yaml setlocal tabstop=2 softtabstop=2 shiftwidth=2
augroup END
" }}}

" https://vim-jp.org/vimdoc-ja/options.html#'wildmode'
" wildmenuã‚’æœ‰åŠ¹ã«ã™ã‚‹ {{{
set wildmenu
" }}}

" grepã—ãŸçµæœã‚’quickfixã«è¡¨ç¤ºã™ã‚‹ {{{
augroup grepwindow
	au!
	au QuickFixCmdPost *grep* cwindow
augroup END
" }}}

" ã‚«ãƒ¼ã‚½ãƒ«ãƒ©ã‚¤ãƒ³ã®ä½ç½®ã‚’ä¿å­˜ã™ã‚‹ {{{
augroup cursorlineRestore
	autocmd!
	autocmd BufReadPost *
				\ if line("'\"") > 0 && line("'\"") <= line("$") |
				\   exe "normal! g'\"" |
				\ endif
augroup END
" }}}

" undoã®ä¿å­˜å…ˆ {{{
if has('persistent_undo')
	let undo_path = expand('~/.vim/undo')
	exe 'set undodir=' .. undo_path
	set undofile
endif
" }}}

" visualãƒ¢ãƒ¼ãƒ‰ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚«ãƒ©ãƒ¼ {{{
"hi Visual cterm=reverse ctermbg=NONE
" }}}

" çŸ©å½¢é¸æŠæ™‚ã«æ–‡å­—ã®ç„¡ã„ã¨ã“ã‚ã¾ã§é¸æŠç¯„å›²ã‚’åºƒã’ã‚‹ {{{
set virtualedit=block
" }}}

" ãƒ˜ãƒ«ãƒ—ã®è¨€èªã‚’æ—¥æœ¬èªå„ªå…ˆã«ã™ã‚‹ {{{
set helplang=ja
" }}}

" {{{
set autowrite
" }}}
"
"set ambiwidth=double

" ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜æ™‚ã«æ•´å½¢ã™ã‚‹ {{{
" key is file type, value is command args
let s:format_targets = {
			\ 'javascript': '--use-tabs=true --tab-width=4 --single-quote=true %',
			\ 'html': '--use-tabs=true --tab-width=4 --single-quote=true %',
			\ 'css': '',
			\ 'json': '--tab',
			\ 'vue':  '--use-tabs=true --tab-width=4 --single-quote=true %',
			\ 'vim': '',
			\ 'java': '',
			\ }

" format function
function! Format() abort
	" if format target is not exsist, nothing to do
	if !has_key(s:format_targets, &ft)
		return
	endif

	let args = s:format_targets[&ft]
	let pos = getcurpos()

	" use js-beautify to format js, html, css
	if &ft is# 'javascript' || &ft is# 'html' || &ft is# 'vue'
		if executable('prettier')
			exe '%!prettier ' .. args
		else
			call s:echo_err("prettier doesn't installed, please refference the https://github.com/beautify-web/js-beautify")
		endif
	elseif &ft is# 'css'
		" TODO
	elseif &ft is# 'json'
		if executable('jq')
			exe "%!jq " .. args
		else
			call s:echo_err("jq doesn't installed, please refference the https://stedolan.github.io/jq/")
		endif
	else
		execute 'normal 1G=G'
	endif

	call setpos('.', pos)
endfunction

nnoremap <C-f> :call Format()<CR>

"augroup format
"	autocmd!
"	autocmd BufWritePre * call Format()
"augroup END
" }}}

" ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªé…ä¸‹ã®.vimã‚’ã™ã¹ã¦sourceã™ã‚‹ {{{
function! SourceDir(...) abort
	let l:path = getcwd()
	if a:0 > 1
		let l:path = a:1
	endif

	if !isdirectory(l:path)
		return
	endif

	exe 'set rtp^=' . l:path
	if isdirectory(l:path . '/plugin')
		exe 'runtime plugin/*.vim'
	endif

	if isdirectory(l:path . '/autoload')
		exe 'runtime autoload/*.vim'
	endif

	if isdirectory(l:path . '/syntax')
		exe 'runtime syntax/*.vim'
	endif
endfunction

command! -nargs=* Source call SourceDir(<f-args>)
" }}}

" listã®è¨­å®š {{{
set list
set listchars=tab:Â»-,trail:-,extends:Â»,precedes:Â«,nbsp:%
"hi NonText    ctermbg=None ctermfg=Yellow
"hi SpecialKey ctermbg=None ctermfg=Yellow
" }}}

" {{{ è¡Œæœ«ã®ãƒ›ãƒ¯ã‚¤ãƒˆã‚¹ãƒšãƒ¼ã‚¹å‰Šé™¤
augroup HighlightTrailingSpaces
	autocmd!
	autocmd BufWritePre * :silent keeppatterns %s/\s\+$//ge
	autocmd VimEnter,WinEnter,ColorScheme * highlight TrailingSpaces term=underline guibg=Red ctermbg=Red
	autocmd VimEnter,WinEnter * match TrailingSpaces /\s\+$/
augroup END
" }}}

" swapãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ãªã„
set noswapfile

" ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§ä¿å­˜ã™ã‚‹å¯¾è±¡ã‚’è¨­å®šã™ã‚‹
if !has('nvim')
	set sessionoptions=blank,buffers,curdir,folds,help,tabpages,winsize,terminal
endif

" ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºè‡ªå‹•èª¿æ•´ã‚’ç„¡åŠ¹åŒ–
set noequalalways

" ã‚¿ãƒ–ã‚’å¸¸ã«è¡¨ç¤º
set showtabline=2

" å¤–éƒ¨ã§ãƒ•ã‚¡ã‚¤ãƒ«ã®å¤‰æ›´ãŒã‚ã£ãŸå ´åˆã€è‡ªå‹•çš„ã«èª­ã¿ç›´ã™
set autoread
augroup vimrc-misc
	au!
	autocmd WinEnter,FocusGained * checktime
augroup END
" }}}

" key mappings {{{
" *ã§ã‚«ãƒ¼ã‚½ãƒ«ã‚’ç§»å‹•ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
noremap * *N

" ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã¨çµ‚äº† {{{
nnoremap <Leader>w :w<CR>
nnoremap <Leader>q :q!<CR>
" }}}

" æ¤œç´¢
nnoremap <C-G><C-G> :Ggrep <C-R><C-W><CR><CR>

" ç½®æ›
nnoremap <Leader>re :%s;\<<C-R><C-W>\>;g<Left><Left>;

" visualã§é¸æŠã—ãŸãƒ†ã‚­ã‚¹ãƒˆã‚’ç½®æ›ã™ã‚‹
vnoremap <Leader>re y:%s;<C-r>=substitute(@", "<C-v><NL>", "\\\\n", "g")<CR>;;g<Left><Left>

" ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’å‰Šé™¤ã™ã‚‹
nnoremap <Esc><Esc> :nohlsearch<CR>

" vimrcã‚’é–‹ã
nnoremap <Leader>. :new ~/.vimrc<CR>
nnoremap <Leader>s :source ~/.vimrc<CR>

" ãƒ†ã‚­ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚­ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚° {{{
onoremap 8 i(
onoremap 2 i"
onoremap 7 i'
onoremap @ i`
onoremap [ i[
onoremap { i{

onoremap a8 a(
onoremap a2 a"
onoremap a7 a'
onoremap a@ a`
onoremap a[ a[
onoremap a{ a{

" visual
nnoremap v8 vi(
nnoremap v2 vi"
nnoremap v7 vi'
nnoremap v@ vi`
nnoremap v[ vi[
nnoremap v{ vi{

nnoremap va8 va(
nnoremap va2 va"
nnoremap va7 va'
nnoremap va@ va`
nnoremap va[ va[
nnoremap va{ va{
" }}}

" è¡Œå…ˆé ­ã¨è¡Œæœ«
noremap H ^
noremap L $

" ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
nnoremap <C-l> gt
nnoremap <C-h> gT

" visualæ™‚ã«é¸æŠè¡Œã‚’ç§»å‹•
"vnoremap <C-j> :m '>+1<CR>gv
"vnoremap <C-k> :m '<-2<CR>gv

" numberã¨relativenumberã®åˆ‡ã‚Šæ›¿ãˆ
nnoremap <silent> <Leader>n :set relativenumber!<CR>

" è‡ªä½œã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ©ãƒ³ãƒãƒ£ãƒ¼
nnoremap <silent> <Leader>l :bo term ++close gol -f<CR>

" visual paste
vnoremap <silent> <C-p> "0p<CR>

" ã‚¿ãƒ¼ãƒŸãƒŠãƒ«é–¢é€£ {{{

" ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚’é–‹ã
" a:1 new or vnew or tabnew(default is new)
" a:2 path (default is current)
" a:3 shell (default is &shell)
function! s:open_terminal(...) abort
	let open_type = 'new'
	let shell = &shell
	let path = getcwd()

	if a:0 > 0 && a:0 !=# ''
		let open_type = a:1
	endif
	if a:0 > 1 && a:2 !=# ''
		let path = a:2
	endif
	if a:0 > 2 && a:3 !=# ''
		let shell = a:3
	endif
	if open_type ==# 'new'
		let open_type = open_type
	endif

	exe printf('%s | lcd %s', open_type, path)
	exe printf('term ++curwin ++close %s', shell)
	exe 'call term_setrestore("%", printf("++close bash -c \"cd %s && bash\"", getcwd()))'
endfunction

command! -nargs=* OpenTerminal call s:open_terminal(<f-args>)

" ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚’é–‹ã
"noremap <silent> <C-s>\ :OpenTerminal vnew<CR>
"noremap <silent> <C-s>- :OpenTerminal<CR>
"noremap <silent> <C-s>^ :OpenTerminal tabnew<CR>
"tnoremap <silent> <C-s>\ <C-w>:OpenTerminal vnew<CR>
"tnoremap <silent> <C-s>- <C-w>:OpenTerminal<CR>
"tnoremap <silent> <C-s>^ <C-w>:OpenTerminal tabnew<CR>

" ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ãƒãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰
tnoremap <C-w>n <C-w>N

" ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ç§»å‹•
tnoremap <silent> <C-h> <C-w>:tabprevious<CR>
tnoremap <silent> <C-l> <C-w>:tabnext<CR>

" ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºé–‹å§‹
"tnoremap <C-w><C-e> <C-w>:WinResizerStartResize<CR>

"set termwinkey=<C-g>

" å˜èªå‰Šé™¤
tnoremap <C-g> <C-w>.
" }}}

" ä¸Šä¸‹ã®ç©ºç™½ã«ç§»å‹•
nnoremap <C-j> }
nnoremap <C-k> {

" review
augroup review
	au!
	au FileType review vnoremap <silent> <buffer> <Leader>hi c@<cursor>{<c-r>"}<esc>
augroup END

" æ”¹è¡Œ
nnoremap gj o<esc>
nnoremap gk O<esc>

" git status
nnoremap gs :Gstatus<CR>

" ãƒãƒƒãƒ•ã‚¡ä¸€è¦§
nnoremap gb :Buffers<CR>

" ãƒ˜ãƒ«ãƒ—
augroup help-mapping
	au!
	au FileType help nnoremap <buffer> <silent>q :bw!<CR>
augroup END

" ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã§å˜èªç§»å‹• {{{
cnoremap <c-b> <S-Left>
cnoremap <c-f> <S-Right>
cnoremap <c-a> <Home>
" }}}

" }}}

" vim-go settings {{{
" ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜æ™‚go importã‚’å®Ÿè¡Œã™ã‚‹
let g:go_fmt_command = 'goimports'

" goplsã‚’ç„¡åŠ¹åŒ–
let g:go_gopls_enabled = 0

" ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜æ™‚ã€linterã‚’å®Ÿè¡Œã™ã‚‹
let g:go_metalinter_autosave = 1

" linterå®Ÿè¡Œæ™‚ã€go vetã®ã¿ã‚’å®Ÿè¡Œã™ã‚‹
let g:go_metalinter_autosave_enabled = ['vet']

" golangci-lintã‚’ä½¿ã†
let g:go_metalinter_command = "golangci-lint"

" vim-lspã‚’ã—ã‚ˆã†ã™ã‚‹ã®ã§ã€vim-goã®`Ctrl+]`ã‚’ç„¡åŠ¹ã«ã™ã‚‹
let g:go_def_mapping_enabled = 0

" GoDocã§ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½¿ç”¨ã™ã‚‹
"let g:go_doc_popup_window = 1

" GoRunã‚„GoTestæ™‚ã®ç”»é¢åˆ†å‰²æ–¹æ³•å¤‰æ›´
let g:go_term_mode = 'split'

" ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆã‚’ç„¡åŠ¹åŒ–
let g:go_template_autocreate = 0

" ã™ã§ã«é–‹ã„ã¦ã„ã‚‹ãƒãƒƒãƒ•ã‚¡ã«å®šç¾©ã‚¸ãƒ£ãƒ³ãƒ—ã™ã‚‹
let g:go_def_reuse_buffer = 1

" goplsã§å®šç¾©ã‚¸ãƒ£ãƒ³ãƒ—
"let g:go_def_mode = 'gopls'

let g:go_fold_enable = ['block', 'import', 'varconst', 'package_comment']

" key mapping
augroup goMapping
	autocmd!
	au FileType go set foldmethod=syntax
augroup END
" }}}

" fzf settings {{{
" ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’å‡ºã™ã¨ãã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
command! -bang -nargs=? -complete=dir Files
			\ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)
nnoremap <C-P> :Files<CR>
" }}}

" lsp settings {{{
nnoremap <silent> <C-]> :LspDefinition<CR>
nnoremap <silent> <Leader>rf :LspReferences<CR>
nnoremap <silent> <Leader>im :LspImplementation<CR>
nnoremap <silent> gp :LspPeekDefinition<CR>

" éåŒæœŸè£œå®Œã‚’æœ‰åŠ¹ã«ã™ã‚‹
"let g:lsp_async_completion = 1

" lsp log
"let g:lsp_log_verbose = 0
"let g:lsp_log_file = expand('~/vim-lsp.log')

" enable signs
let g:lsp_signs_error = {'text': 'ï½³ï¾'}
let g:lsp_signs_warning = {'text': 'ğŸŒ'}
let g:lsp_signs_enabled = 1
"let g:lsp_diagnostics_echo_cursor = 1

" Go {{{
augroup LspGo
	au!
	if executable('gopls')
		au User lsp_setup call lsp#register_server({
					\ 'name': 'gopls',
					\ 'cmd': {server_info->['gopls', '-mode', 'stdio']},
					\ 'whitelist': ['go'],
					\ })
	endif
augroup END
" }}}

" PHP {{{
"augroup LspPHP
"	au!
"	au User lsp_setup call lsp#register_server({
"				\ 'name': 'php-language-server',
"				\ 'cmd': {server_info->['php', expand('~/.cache/dein/repos/github.com/felixfbecker/php-language-server/bin/php-language-server.php')]},
"				\ 'whitelist': ['php'],
"				\ })
"augroup END
" }}}

" JavaScript {{{
"augroup LspJavaScript
"	au!
"	if executable('flow-language-server')
"		au User lsp_setup call lsp#register_server({
"					\ 'name': 'flow-language-server',
"					\ 'cmd': {server_info->[&shell, &shellcmdflag, 'flow-language-server --stdio']},
"					\ 'root_uri':{server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_file_directory(lsp#utils#get_buffer_path(), '.flowconfig'))},
"					\ 'whitelist': ['javascript', 'javascript.jsx'],
"					\ })
"	endif
"augroup END
" }}}

" Docker {{{
"augroup LspDocker
"	au!
"	if executable('docker-langserver')
"		au User lsp_setup call lsp#register_server({
"					\ 'name': 'docker-langserver',
"					\ 'cmd': {server_info->[&shell, &shellcmdflag, 'docker-langserver --stdio']},
"					\ 'whitelist': ['dockerfile'],
"					\ })
"	endif
"augroup END
" }}}

" CSS {{{
"augroup LspCSS
"	au!
"	if executable('css-languageserver')
"		au User lsp_setup call lsp#register_server({
"					\ 'name': 'css-languageserver',
"					\ 'cmd': {server_info->[&shell, &shellcmdflag, 'css-languageserver --stdio']},
"					\ 'whitelist': ['css', 'less', 'sass'],
"					\ })
"	endif
"augroup END
" }}}

" clang {{{
"augroup LspClangd
"	if executable('clangd')
"		au!
"		au User lsp_setup call lsp#register_server({
"					\ 'name': 'clangd',
"					\ 'cmd': {server_info->['clangd', '-background-index']},
"					\ 'whitelist': ['c', 'cpp', 'objc', 'objcpp'],
"					\ })
"	endif
"augroup END
" }}}

" }}}

" asyncomplete settings {{{
"inoremap <expr> <C-j> pumvisible() ? "\<C-n>" : "\<Tab>"
"inoremap <expr> <C-k> pumvisible() ? "\<C-p>" : "\<S-Tab>"
"inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<cr>"
" }}}

" vim-markdown settings {{{
" mdã‚’é–‹ãã¨ãã®æŠ˜ã‚ŠãŸãŸã¿ã‚’ç„¡åŠ¹ã«ã™ã‚‹
let g:vim_markdown_folding_disabled = 1
" }}}

" vim-surround settings {{{
nmap <Leader>7 ysiw'
nmap <Leader>2 ysiw"
nmap <Leader>` ysiw`
nmap <Leader>8 ysiw)
nmap <Leader>[ ysiw]
nmap <Leader>{ ysiw}
" }}}

" ultisnips settings {{{
"let g:UltiSnipsExpandTrigger="<C-f>"
"let g:UltiSnipsJumpForwardTrigger="<tab>"
"let g:UltiSnipsJumpBackwardTrigger="<s-tab>"

" ultisnipesè‡ªå‹•è£œå®Œ
"if has('python3')
"    call asyncomplete#register_source(asyncomplete#sources#ultisnips#get_source_options({
"                \ 'name': 'ultisnips',
"                \ 'whitelist': ['*'],
"                \ 'completor': function('asyncomplete#sources#ultisnips#completor'),
"                \ }))
"endif
" }}}

" profiling {{{
" vim +'call ProfileCursorMove()' <ã‚«ãƒ¼ã‚½ãƒ«ã‚’å‹•ã‹ã™ã®ãŒé‡ã„ãƒ•ã‚¡ã‚¤ãƒ«>
function! ProfileCursorMove() abort
	let profile_file = expand('./vim-profile.log')
	if filereadable(profile_file)
		call delete(profile_file)
	endif

	normal! ggzR

	execute 'profile start ' . profile_file
	profile func *
	profile file *

	augroup ProfileCursorMove
		autocmd!
		autocmd CursorHold <buffer> profile pause | q
	augroup END

	for i in range(1000)
		call feedkeys('j')
	endfor
endfunction
" }}}

" emment {{{
let g:user_emmet_install_global = 0
let g:user_emmet_settings = {
			\ 'variables': {
			\   'lang' : 'ja'
			\ }
			\}

augroup emmet
	autocmd!
	au FileType vue,html,js EmmetInstall
	au FileType vue,html,js imap <buffer> <C-f> <plug>(emmet-expand-abbr)
augroup END
" }}}

" lightline {{{
set laststatus=2
if !has('gui_running')
	set t_Co=256
endif
" }}}

" vim-vue {{{
" https://github.com/posva/vim-vue#my-syntax-highlighting-stops-working-randomly
" vueãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãŒåŠ¹ã‹ãªããªã‚‹å•é¡Œå¯¾å¿œ
augroup VueSyntax
	autocmd!
	au FileType vue syntax sync fromstart
augroup END
" }}}

" gitgutter {{{
" ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ç„¡åŠ¹ã«ã™ã‚‹
"highlight default link GitGutterAdd          NONE
"highlight default link GitGutterChange       NONE
"highlight default link GitGutterDelete       NONE
"highlight default link GitGutterChangeDelete NONE
" }}}

" nerd commenter {{{
" ã‚³ãƒ¡ãƒ³ãƒˆã®å¾Œã«ã‚¹ãƒšãƒ¼ã‚¹ã‚’è£…å…¥
let g:NERDSpaceDelims = 1
" }}}

" calendar.vim {{{
" Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸ
let g:calendar_google_calendar = 1
" }}}

" sonictemplate.vim {{{
let g:sonictemplate_author = 'skanehira'
let g:sonictemplate_license = 'MIT'
" }}}

" vimhelpgenarator {{{
let g:vimhelpgenerator_version = 'Version : 0.0.1'
let g:vimhelpgenerator_author = 'Author  : skanehira <sho19921005@gmai.com>'
let g:vimhelpgenerator_uri = 'https://github.com/skanehira/'
let g:vimhelpgenerator_defaultlanguage = 'en'
" }}}

" {{{ MemoList
let g:memolist_fzf = 1
" }}}

" silicon {{{
if executable('silicon')
	let g:silicon = {
				\ 'theme':              'Dracula',
				\ 'font':                  'Hack',
				\ 'background':         '#aaaaff',
				\ 'shadow-color':       '#555555',
				\ 'line-pad':                   2,
				\ 'pad-horiz':                  0,
				\ 'pad-vert':                   0,
				\ 'shadow-blur-radius':         0,
				\ 'shadow-offset-x':            0,
				\ 'shadow-offset-y':            0,
				\ 'line-number':           v:true,
				\ 'round-corner':          v:true,
				\ 'window-controls':       v:true,
				\ }
endif
" }}}

" vsession {{{
let g:vsession_use_fzf = 1
" }}}

" {{{ lexima
let g:lexima_enable_basic_rules = 1
" }}}

" {{{ docker.vim
let g:docker_terminal_open = 'top'
"let s:docker_auth_file = expand('~/.docker/docker.vim.json')
"let g:docker_registry_auth = json_decode(join(readfile(s:docker_auth_file), "\n"))
" }}}

" {{{ markdown-preview.nvim
let g:mkdp_auto_close = 0
" }}}

" {{{ vim-textlint
let g:textlint_enable_quickfix = 1
" }}}

if $WSL_DISTRO_NAME != ''
    augroup yankpost
        au!
        autocmd TextYankPost * call system('win32yank.exe -i', v:event.regcontents)
    augroup END

    nnoremap <silent> p :call setreg('"',system('win32yank.exe -o')) \| :put<CR>
    nnoremap <silent> P :call setreg('"',system('win32yank.exe -o')) \| :put!<CR>
endif

" {{{ è‡ªä½œé–¢æ•°

" {{{ ãƒªãƒã‚¸ãƒˆãƒªã«ç§»å‹•
function! s:cd_repo(shell, repo) abort
	exe 'lcd' trim(system('ghq root')) .. '/' .. a:repo
	pwd
endfunction

function! s:repo(multi, cb) abort
	if executable('ghq') && exists('*fzf#run()') && executable('fzf')
		call fzf#run({
					\ 'source': systemlist('ghq list'),
					\ 'sink': a:cb,
					\ 'options': a:multi,
					\ 'down': '40%'},
					\ )
	else
		echo "doesn't installed ghq or fzf.vim(require fzf)"
	endif
endfunction

command! Repo call s:repo('+m', function('s:cd_repo', [&shell]))
" }}}

" æ–°ã—ã„ã‚¿ãƒ–ã‚’é–‹ã {{{
function! s:open_tabs(shell, repo) abort
	exe printf('tabnew | lcd %s/%s', trim(system('ghq root')), a:repo)
endfunction

" fzf.vimã®callbackã§ã¯&shellãŒshã«ãªã£ã¦ã—ã¾ã†ã®ã§ã€ç¾åœ¨å®Ÿè¡Œã—ã¦ã„ã‚‹shellã‚’æ¸¡ã™
command! NewTab call s:repo('-m', function('s:open_tabs', [&shell]))

" }}}

" {{{ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä¸€è¦§
function! s:get_win_info() abort
	let l:win_info_list = []
	for win in getwininfo()
		if !has_key(win.variables, "netrw_prvfile")
			continue
		endif
		let l:tmp_file = split(win.variables.netrw_prvfile, '/')
		if empty(tmp_file)
			let l:file = '[No Name]'
		else
			let l:file = l:tmp_file[len(tmp_file)-1:][0]
		endif
		call add(l:win_info_list, {'winid':win.winid, 'file': l:file})
	endfor
	return l:win_info_list
endfunction

function! s:goto_window(ctx, id, idx) abort
	if a:idx ==# -1
		return
	endif
	call win_gotoid(a:ctx[a:idx-1].winid)
endfunction

function! s:win_list() abort
	let l:win_info = s:get_win_info()
	if empty(l:win_info)
		call s:echo_err('cannot find windows')
		return
	endif

	let l:view_content = []
	let l:min_width = 40

	for win in l:win_info
		call add(l:view_content, win.winid . "\t" . win.file)
		if len(win.file) > l:min_width
			let l:min_width = len(win.file)
		endif
	endfor
	call popup_menu(l:view_content, {
				\ 'border': [],
				\ 'borderchars': ['-','|','-','|','+','+','+','+'],
				\ 'padding': [0,0,0,0],
				\ 'filter': 'popup_filter_menu',
				\ 'callback': function('s:goto_window', [l:win_info]),
				\ 'minwidth': l:min_width,
				\ })
endfunction

command! Windows call s:win_list()
" }}}

" {{{ ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡ºåŠ›
function! s:echo_err(message) abort
	echohl ErrorMsg
	redraw
	echo a:message
	echohl None
endfunction
" }}}

" {{{ ãƒ•ã‚¡ã‚¤ãƒ«æ¤œç´¢ï¼ˆãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ï¼‰
if !exists('g:loaded_select') && !has('nvim')
	let g:loaded_select = 1
	call prop_type_add('file_select', {'highlight': 'PmenuSel'})
endif

function! s:get_files(path) abort
	let l:entries = []

	for l:entry in readdir(a:path)
		if l:entry[0] ==# '.'
			continue
		endif
		let l:path_entry = a:path . '/' . l:entry
		if isdirectory(l:path_entry)
			let l:entries += s:get_files(l:path_entry)
		else
			if l:path_entry[0] ==# '.'
				let l:path_entry = l:path_entry[2:]
			endif
			cal add(l:entries, l:path_entry)
		endif
	endfor
	return l:entries
endfunction

function! s:highlight(ctx) abort
	let l:buf = winbufnr(a:ctx.id)
	let l:length = len(a:ctx.files[a:ctx.select])
	let l:lnum_end = len(a:ctx.files)
	let l:lnum = a:ctx.select - a:ctx.offset + 1
	if a:ctx.search_mode ==# 1 && !empty(a:ctx.filter_files)
		let l:length = len(a:ctx.filter_files[a:ctx.select])
		let l:lnum_end = len(a:ctx.filter_files)
	endif

	call prop_clear(1, l:lnum_end, {
				\ 'bufnr': l:buf,
				\ })

	call prop_add(l:lnum, 1, {
				\ 'bufnr': l:buf,
				\ 'type': 'file_select',
				\ 'length': l:length,
				\ })

	call win_execute(a:ctx.id, 'redraw')
endfunction

function! s:update_files(ctx) abort
	let l:files = copy(a:ctx.files)
	if a:ctx.search_mode
		let l:tmp = []
		for file in l:files
			if file =~? a:ctx.word[1:]
				call add(l:tmp, file)
			endif
		endfor
		let l:files = l:tmp
		let a:ctx.filter_files = l:tmp
	endif
	echo a:ctx.word
	call popup_settext(a:ctx.id, l:files[a:ctx.offset:])
	call s:highlight(a:ctx)
	redraw
endfunction

function! s:popup_filter(ctx, id, key) abort
	let l:buf = winbufnr(a:id)
	let l:file = a:ctx.files[a:ctx.select]

	if a:ctx.search_mode ==# 0
		if a:key ==# 'q' || a:key ==# 'x'
			call popup_close(a:id)
			return 1
		elseif a:key ==# '/'
			let a:ctx.search_mode = 1
			let a:ctx.word .= a:key
		elseif a:key ==# "\n" || a:key ==# "\r"
			return s:open_file(a:id, 'e', l:file)
		elseif a:key ==# ""
			return s:open_file(a:id, 'new', l:file)
		elseif a:key ==# ""
			return s:open_file(a:id, 'vnew', l:file)
		elseif a:key ==# ""
			return s:open_file(a:id, 'tabnew' , l:file)
		elseif a:key ==# 'j'
			let a:ctx.select += a:ctx.select ==# len(a:ctx.files)-1 ? 0 : 1
			if a:ctx.select >= a:ctx.offset + a:ctx.maxheight
				let a:ctx.offset = a:ctx.select - (a:ctx.maxheight - 1)
			endif
		elseif a:key ==# 'k'
			let a:ctx.select -= a:ctx.select ==# 0 ? 0 : 1
			if a:ctx.select < a:ctx.offset
				let a:ctx.offset = a:ctx.select
			endif
		elseif a:key ==# '0'
			let a:ctx.select = 0
			let a:ctx.offset = 0
		elseif a:key ==# 'G'
			let a:ctx.select = len(a:ctx.files)-1
			let a:ctx.offset = len(a:ctx.files) - (a:ctx.maxheight)
		endif
	else
		" æ¤œç´¢ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆ
		if !empty(a:ctx.filter_files)
			let l:file = a:ctx.filter_files[a:ctx.select]
		else
			let l:file = ''
		endif
		if a:key ==# "\<bs>" || a:key ==# "\b"
			if strlen(a:ctx.word) == 1
				let a:ctx.word = ''
				let a:ctx.search_mode = 0
			else
				let a:ctx.word = a:ctx.word[:len(a:ctx.word)-2]
			endif
		elseif a:key ==# '}'
			let a:ctx.select += a:ctx.select ==# len(a:ctx.filter_files)-1 ? 0 : 1
			if a:ctx.select >= a:ctx.offset + a:ctx.maxheight
				let a:ctx.offset = a:ctx.select - (a:ctx.maxheight - 1)
			endif
		elseif a:key ==# '{'
			let a:ctx.select -= a:ctx.select ==# 0 ? 0 : 1
			if a:ctx.select < a:ctx.offset
				let a:ctx.offset = a:ctx.select
			endif
		elseif a:key ==# "\n" || a:key ==# "\r"
			return s:open_file(a:id, 'e', l:file)
		elseif a:key ==# ""
			return s:open_file(a:id, 'new', l:file)
		elseif a:key ==# ""
			return s:open_file(a:id, 'vnew', l:file)
		elseif a:key ==# ""
			return s:open_file(a:id, 'tabnew' , l:file)
		elseif a:key !=# "\<CursorHold>"
			let a:ctx.select = 0
			let a:ctx.offset = 0
			let a:ctx.word .= a:key
		endif
	endif

	if a:key !=# "\<CursorHold>"
		call s:update_files(a:ctx)
	endif
	return 1
endfunction

function! s:open_file(id, key, file) abort
	if empty(a:file)
		return 1
	endif
	call popup_close(a:id)
	exe a:key a:file
	return 1
endfunction

function! s:popup_files(...) abort
	let l:path = '.'
	if a:0 > 0
		let l:path = a:1
	endif

	let l:files = s:get_files(l:path)
	if empty(l:files)
		echo 'not any files'
		return
	endif

	let l:ctx = { 'select': 0,
				\ 'files': l:files,
				\ 'offset': 0,
				\ 'maxheight': 15,
				\ 'word' : '',
				\ 'search_mode': 0,
				\ 'filter_files': [],
				\ }

	let l:maxwidth = 0
	for file in l:ctx.files
		let length = len(file)
		if length > l:maxwidth
			let l:maxwidth = length
		endif
	endfor

	let l:ctx.id = popup_create(l:ctx.files, {
				\ 'filter': function('s:popup_filter', [l:ctx]),
				\ 'borderchars': ['-','|','-','|','+','+','+','+'],
				\ 'border': [],
				\ 'maxheight': l:ctx.maxheight,
				\ 'minwidth': l:maxwidth,
				\ 'padding': [0,0,0,0],
				\ 'mapping': 0,
				\ })

	call s:highlight(l:ctx)
endfunction

command! -nargs=? PopupFiles call s:popup_files(<f-args>)
" }}}

" {{{ gitã‚³ãƒãƒ³ãƒ‰é–¢é€£
" options:
" {
"	cmd: 'diff'
"	args: [
"		'HEAD^',
"	],
"	auto_close: 0,	" 1: true, 0: false
"	window_way: 'bo',	" tab, bo, vert, term, etc...
"	mode: 'term', " term, popup, fzf
"	focus: 1008, " window id
"	source: [], " fzf source
"	cb: functionm "fzf callback
" }
function! s:git_exec(opt) abort
	let current_winid = win_getid()
	if a:opt.mode is# 'term'
		let cmd = 'git ' .. a:opt.cmd
		if has_key(a:opt, 'args') && !empty(a:opt.args)
			let cmd = cmd .. ' ' .. join(a:opt.args, ' ')
		endif
		if has_key(a:opt, 'auto_close') && a:opt.auto_close is# 1
			let cmd = a:opt.window_way .. ' term ++rows=10 ++close ' .. cmd
		else
			let cmd = a:opt.window_way .. ' term ++rows=10 ' .. cmd
		endif
		exec cmd
		nnoremap <buffer> <silent> q :bw!<CR>
	elseif a:opt.mode is# 'pop'
		" TODO use popup window
	elseif a:opt.mode is# 'fzf'
		if exists('*fzf#run()') && executable('fzf')
			call fzf#run({
						\ 'source': a:opt.source,
						\ 'sink': a:opt.cb,
						\ 'down': '40%'},
						\ )
		endif
	else
		call s:echo_err("doesn't installed fzf.vim(require fzf)")
	endif

	call win_gotoid(current_winid)
endfunction

function! s:git_log() abort
	" use fish command
	call system('tmux new-window fish -c "gitlog"')
endfunction

function! s:git_push(...) abort
	let opt = {
				\ 'cmd': 'push',
				\ 'args': a:000,
				\ 'auto_close': 1,
				\ 'window_way': 'top',
				\ 'mode': 'term',
				\ }

	call s:git_exec(opt)
endfunction

function! s:git_pull(...) abort
	let opt = {
				\ 'cmd': 'pull',
				\ 'args': a:000,
				\ 'auto_close': 0,
				\ 'window_way': 'top',
				\ 'mode': 'term',
				\ }

	call s:git_exec(opt)
endfunction

function! s:git_checkout_cb(repo) abort
	call system('git checkout' .. a:repo)
endfunction

function! s:git_checkout(...) abort
	let source = filter(systemlist('git branch'), 'v:val[0] isnot# "*"')
	if empty(source)
		call s:echo_err("no other branch")
		return
	endif

	let opt = {
				\ 'source': source,
				\ 'mode': 'fzf',
				\ 'cb': function('s:git_checkout_cb'),
				\ }

	call s:git_exec(opt)
endfunction

command! -nargs=* Gitpush call s:git_push(<f-args>)
command! -nargs=* Gitpull call s:git_pull()
command! -nargs=* Gitblame call s:git_blame()
command! -nargs=* GitCheckout call s:git_checkout(<f-args>)
command! Gitlog call s:git_log()
command! Lazygit call system('tmux new-window lazygit')
command! Pst call system('tmux split-window -h pst')
command! Docui call system('tmux new-window docui')

nnoremap <silent> gl :Lazygit<CR>
nnoremap <silent> gc :GitCheckout<CR>

" }}}

" {{{ ãƒãƒƒãƒ•ã‚¡é–¢é€£
function! s:buflist() abort
	return filter(range(1, bufnr('$')), 'buflisted(v:val) && getbufvar(v:val, "&filetype") != "qf"')
endfunction

function! s:format_buffer(b)
	let name = bufname(a:b)
	let name = empty(name) ? '[No Name]' : fnamemodify(name, ":p:~:.")
	let flag = a:b == bufnr('')  ? '%' : a:b == bufnr('#') ? '#' : ' '
	let modified = getbufvar(a:b, '&modified') ? ' [+]' : ''
	let readonly = getbufvar(a:b, '&modifiable') ? '' : ' [RO]'
	let extra = join(filter([modified, readonly], '!empty(v:val)'), '')
	return printf("[%s] %s\t%s\t%s", a:b, flag, name, extra)
endfunction

function! s:delbuf(buf) abort
	exe 'bw!' a:buf[match(a:buf, '[')+1:match(a:buf, ']')-1]
endfunction

function! s:delbuflist() abort
	call fzf#run({
				\ 'source': map(copy(s:buflist()), 's:format_buffer(v:val)'),
				\ 'sink': function('s:delbuf'),
				\ 'options': "-m",
				\ 'down': '40%'},
				\ )
endfunction

command! DelBuf call s:delbuflist()
" }}}

" {{{ ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªè‡ªå‹•ç”Ÿæˆ
augroup vimrc-auto-mkdir
	autocmd!
	autocmd BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'), v:cmdbang)
	function! s:auto_mkdir(dir, force)
		if !isdirectory(a:dir) && (a:force ||
					\    input(printf('"%s" does not exist. Create? [y/N]', a:dir)) =~? '^y\%[es]$')
			call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
		endif
	endfunction
augroup END
" }}}

" }}}

" vim: tw=78 sw=4 foldmethod=marker
